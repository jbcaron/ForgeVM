var searchIndex = new Map(JSON.parse('[\
["forge_vm",{"doc":"","t":"PPPPPPPPPPGPPPPPPPPPPPPPPPPPPPPPPPPFGPOOOOCOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOFNNCOCCNCCNCONCNCOONNNFFNNNNONNNNNNNNNNNNONONOOONNNNNNNOFNNNNNNHHHNNNPPPPPPPPPIPPGNNNNNNNNNNNNNNOOOOOOSPPPPPPPPPPPPPPPPPPGPPPPPPPPPPPPPPPPPPPPPPGPPPPPPPPPPPPNNNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOFNNNNONNNNNNNNFNNONNNNNNNNFNNNONONNNNNNNNNNN","n":["ADD","AND","CALL","CLF","CMP","DEC","DIV","DivisionByZero","HLT","INC","Instruction","InvalidInstruction","InvalidOpcode","InvalidRegister","JMP","JMPN","JMPP","JMPZ","LD","MOD","MOV","MULT","MemoryNotAligned","MemoryOutOfBounds","NOP","NOT","OR","Other","POPREG","PUSHREG","RET","ST","SUB","StackOverflow","StackUnderflow","VM","VmError","XOR","cpu","memory","stack","steps","vm","address","address","address","address","address","address","address","dest","dest","dest","dest","dest","dest","dest","dest","dest","dest","dest","reg","reg","reg","reg","reg","reg1","reg1","reg1","reg1","reg1","reg1","reg1","reg1","reg1","reg2","reg2","reg2","reg2","reg2","reg2","reg2","reg2","reg2","src","value","address","address","opcode","register","size","size","VM","borrow","borrow_mut","cpu","cpu","decoder","error","from","hardware_config","instructions","into","memory","memory","new","program","run","stack","stack","steps","try_from","try_into","type_id","CPU","StatusFlags","borrow","borrow","borrow_mut","borrow_mut","carry","clear","clone","clone_into","default","execute_instruction","fmt","from","from","get_register","init","into","into","negative","new","overflow","pc","pc","registers","status_flags","to_owned","try_from","try_from","try_into","try_into","type_id","type_id","zero","Decoder","borrow","borrow_mut","decode_next_instruction","from","into","new","read_i32","read_u32","register_address","try_from","try_into","type_id","DivisionByZero","Err","InvalidInstruction","InvalidOpcode","InvalidRegister","MemoryNotAligned","MemoryOutOfBounds","Ok","Other","Result","StackOverflow","StackUnderflow","VmError","borrow","borrow_mut","clone","clone_into","eq","fmt","fmt","from","into","to_owned","to_string","try_from","try_into","type_id","address","address","opcode","register","size","size","REGISTERS_COUNT","ADD","ADD","AND","AND","CALL","CALL","CLF","CLF","CMP","CMP","DEC","DEC","DIV","DIV","HLT","HLT","INC","INC","Instruction","JMP","JMP","JMPN","JMPN","JMPP","JMPP","JMPZ","JMPZ","LD","LD","MOD","MOD","MOV","MOV","MULT","MULT","NOP","NOP","NOT","NOT","OR","OR","OpCode","POPREG","POPREG","PUSHREG","PUSHREG","RET","RET","ST","ST","SUB","SUB","XOR","XOR","borrow","borrow","borrow_mut","borrow_mut","clone","clone","clone_into","clone_into","eq","eq","fmt","fmt","fmt","from","from","into","into","size","size","to_owned","to_owned","to_string","try_from","try_from","try_from","try_into","try_into","type_id","type_id","address","address","address","address","address","address","address","dest","dest","dest","dest","dest","dest","dest","dest","dest","dest","dest","reg","reg","reg","reg","reg","reg1","reg1","reg1","reg1","reg1","reg1","reg1","reg1","reg1","reg2","reg2","reg2","reg2","reg2","reg2","reg2","reg2","reg2","src","value","Memory","borrow","borrow_mut","capacity","clear","data","from","into","new","read","try_from","try_into","type_id","write","Program","borrow","borrow_mut","code","from","into","new","size","slice_from","try_from","try_into","type_id","Stack","borrow","borrow_mut","capacity","capacity","clear","data","from","into","is_empty","len","new","peek","pop","push","try_from","try_into","type_id"],"q":[[0,"forge_vm"],[43,"forge_vm::Instruction"],[86,"forge_vm::VmError"],[92,"forge_vm::vm"],[114,"forge_vm::vm::cpu"],[148,"forge_vm::vm::decoder"],[161,"forge_vm::vm::error"],[188,"forge_vm::vm::error::VmError"],[194,"forge_vm::vm::hardware_config"],[195,"forge_vm::vm::instructions"],[278,"forge_vm::vm::instructions::Instruction"],[321,"forge_vm::vm::memory"],[335,"forge_vm::vm::program"],[347,"forge_vm::vm::stack"],[365,"core::result"],[366,"core::any"],[367,"core::fmt"],[368,"core::fmt"],[369,"core::clone"],[370,"core::cmp"],[371,"core::fmt"]],"d":["Add two registers and store the result in a destination …","Logical AND two registers and store the result in a …","Call a function at a specified address in the program This …","Clear the flags This operation clears all the flags in the …","Compare two registers This operation compares the values …","Decrement a register This operation decrements the value …","Divide two registers and store the result in a destination …","Division by zero error.","Halt the program execution This operation stops the …","Increment a register This operation increments the value …","Represents the set of all possible instructions for the …","Invalid instruction encountered. This error is used when …","Invalid opcode encountered. Contains the opcode that …","Invalid register encountered, out of bounds. Contains the …","Jump to a specified address in the program","Jump if negative flag is set","Jump if negative flag is not set","Jump if zero flag is set","Loads a value from the specified <code>address</code> in memory into …","Calculate the remainder of dividing two registers and …","Moves a specified <code>value</code> into the designated <code>dest</code> register.","Multiply two registers and store the result in a …","Memory access not aligned. Contains the address and the …","Memory access out of bounds. Contains the address and the …","No operation. Performs no action and is typically used to …","Logical NOT a register and store the result in a …","Logical OR two registers and store the result in a …","Other error. Contains a description of the error.","Pop the value from the top of the stack into the <code>reg</code> …","Push the value from <code>reg</code> register onto the stack. This …","Return from a function call This operation pops the top of …","Stores the value from <code>src</code> register into the memory at …","Subtract two registers and store the result in a …","Stack overflow error. This error is used when the stack is …","Stack underflow error. This error is used when the stack …","Virtual Machine (VM) designed for 32-bit architecture …","Represents the possible errors that can occur during the …","Logical XOR two registers and store the result in a …","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Virtual Machine (VM) designed for 32-bit architecture …","","","","","","","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","","","Constructs a new instance of the VM.","","Runs the VM with a given program.","","","","","","","The CPU structure used by the VM. The CPU has a fixed …","","","","","","","","","","","Execute an instruction on the CPU. The instruction …","","Returns the argument unchanged.","Returns the argument unchanged.","Get the value of a register by index.","Initialize the CPU by clearing the registers and status …","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","Get the program counter (PC) of the CPU.","","","","","","","","","","","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","Read a little-endian i32 from a slice of bytes the start …","Read a little-endian u32 from a slice of bytes the start …","Check if the register is within the bounds of the …","","","","Division by zero error.","Contains the error value","Invalid instruction encountered. This error is used when …","Invalid opcode encountered. Contains the opcode that …","Invalid register encountered, out of bounds. Contains the …","Memory access not aligned. Contains the address and the …","Memory access out of bounds. Contains the address and the …","Contains the success value","Other error. Contains a description of the error.","This module contains the error types used by the VM. The …","Stack overflow error. This error is used when the stack is …","Stack underflow error. This error is used when the stack …","Represents the possible errors that can occur during the …","","","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","","","","","","","","","","The number of registers in the VM.","Add two registers and store the result in a destination …","","Logical AND two registers and store the result in a …","","Call a function at a specified address in the program This …","","Clear the flags This operation clears all the flags in the …","","Compare two registers This operation compares the values …","","Decrement a register This operation decrements the value …","","Divide two registers and store the result in a destination …","","Halt the program execution This operation stops the …","","Increment a register This operation increments the value …","","Represents the set of all possible instructions for the …","Jump to a specified address in the program","","Jump if negative flag is set","","Jump if negative flag is not set","","Jump if zero flag is set","","Loads a value from the specified <code>address</code> in memory into …","","Calculate the remainder of dividing two registers and …","","Moves a specified <code>value</code> into the designated <code>dest</code> register.","","Multiply two registers and store the result in a …","","No operation. Performs no action and is typically used to …","","Logical NOT a register and store the result in a …","","Logical OR two registers and store the result in a …","","Enumeration of all possible opcodes","Pop the value from the top of the stack into the <code>reg</code> …","","Push the value from <code>reg</code> register onto the stack. This …","","Return from a function call This operation pops the top of …","","Stores the value from <code>src</code> register into the memory at …","","Subtract two registers and store the result in a …","","Logical XOR two registers and store the result in a …","","","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","The memory structure used by the VM. The memory has a …","","","Get the capacity of the memory.","Clear the memory by setting all values to zero.","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Create a new memory with the specified size.","Read a value from memory at the specified address. The …","","","","Write a value to memory at the specified address. The …","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","","","","","The stack structure used by the VM. The stack has a fixed …","","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","","","","","","",""],"i":[14,14,14,14,14,14,14,7,14,14,0,7,7,7,14,14,14,14,14,14,14,14,7,7,14,14,14,7,14,14,14,14,14,7,7,0,0,14,3,3,3,3,0,30,31,32,33,34,35,36,37,35,38,39,40,41,42,43,44,45,46,47,48,49,50,46,38,39,40,41,42,43,44,45,51,38,39,40,41,42,43,44,45,51,36,37,52,53,54,55,52,53,0,3,3,0,3,0,0,3,0,0,3,0,3,3,0,3,0,3,3,3,3,3,0,0,12,10,12,10,10,10,10,10,10,12,10,12,10,12,12,12,10,10,12,10,12,12,12,12,10,12,10,12,10,12,10,10,0,19,19,19,19,19,19,0,0,0,19,19,19,7,56,7,7,7,7,7,56,7,0,7,7,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,52,53,54,55,52,53,0,14,24,14,24,14,24,14,24,14,24,14,24,14,24,14,24,14,24,0,14,24,14,24,14,24,14,24,14,24,14,24,14,24,14,24,14,24,14,24,14,24,0,14,24,14,24,14,24,14,24,14,24,14,24,14,24,14,24,14,24,14,24,14,24,14,14,24,14,24,14,24,14,24,14,24,14,14,24,24,14,24,14,24,30,31,32,33,34,35,36,37,35,38,39,40,41,42,43,44,45,46,47,48,49,50,46,38,39,40,41,42,43,44,45,51,38,39,40,41,42,43,44,45,51,36,37,0,15,15,15,15,15,15,15,15,15,15,15,15,15,0,20,20,20,20,20,20,20,20,20,20,20,0,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16],"f":"`````````````````````````````````````````````````````````````````````````````````````````````{ce{}{}}0````{cc{}}``1``{{bb}{{f{d}}}}`{{{f{d}}{j{h}}}{{A`{ln}}}}```{c{{A`{e}}}{}{}}0{cAb{}}``5555`{AdAf}{AdAd}{{ce}Af{}{}}{{}Ad}{{{Ah{d}}{Al{dAj}}An{B`{d}}}{{A`{Afn}}}}{{AdBb}Bd}::{{{Ah{d}}h}{{A`{dn}}}}{{{Ah{d}}}Af}==`{{}{{Ah{d}}}}`{{{Ah{d}}}b}```?;;;;::``??{{BfBhb}{{A`{{Al{dAj}}n}}}}?{ce{}{}}{{}Bf}{{{j{h}}b}{{A`{dn}}}}{{{j{h}}b}{{A`{Ajn}}}}{h{{A`{hn}}}}{c{{A`{e}}}{}{}}0{cAb{}}`````````````66{nn}{{ce}Af{}{}}{{nn}Bj}{{nBb}Bd}0{cc{}};;{cBl{}}776`````````````````````````````````````````````````````````````<<<<{{{Al{ce}}}{{Al{ce}}}BnBn}{C`C`}66{{{Al{ce}}{Al{ce}}}BjCbCb}{{C`C`}Bj}{{{Al{ce}}Bb}BdCdCd}{{{Al{ce}}Bb}BdCf{CfCh}}{{C`Bb}Bd}88{ce{}{}}0{{{Al{ce}}}b{}{}}{C`b}22:{c{{A`{e}}}{}{}}{h{{A`{C`n}}}}111{cAb{}}0````````````````````````````````````````````55{Anb}{AnAf}`{cc{}}8{bAn}{{Anb}{{A`{cn}}}Cj}775{{Anbc}{{A`{Afn}}}{}}`;;`3;{{{j{h}}}Bh}{Bhb}{{Bhb}{{j{h}}}};;9`>>{{{B`{c}}}b{}}`{{{B`{c}}}Af{}}`8{ce{}{}}{{{B`{c}}}Bj{}}3{b{{B`{c}}}{}}{{{B`{c}}}{{A`{cn}}}{}}0{{{B`{c}}c}{{A`{Afn}}}{}}{c{{A`{e}}}{}{}}0{cAb{}}","c":[],"p":[[1,"usize"],[1,"i32"],[5,"VM",92],[1,"u8"],[1,"slice"],[1,"u128"],[6,"VmError",161],[6,"Result",365],[5,"TypeId",366],[5,"StatusFlags",114],[1,"unit"],[5,"CPU",114],[1,"u32"],[6,"Instruction",195],[5,"Memory",321],[5,"Stack",347],[5,"Formatter",367],[8,"Result",367],[5,"Decoder",148],[5,"Program",335],[1,"bool"],[5,"String",368],[10,"Clone",369],[6,"OpCode",195],[10,"PartialEq",370],[10,"Debug",367],[10,"Display",367],[10,"LowerHex",367],[10,"Copy",371],[15,"JMP",278],[15,"JMPN",278],[15,"JMPP",278],[15,"JMPZ",278],[15,"CALL",278],[15,"LD",278],[15,"ST",278],[15,"MOV",278],[15,"ADD",278],[15,"SUB",278],[15,"MULT",278],[15,"DIV",278],[15,"MOD",278],[15,"AND",278],[15,"OR",278],[15,"XOR",278],[15,"NOT",278],[15,"PUSHREG",278],[15,"POPREG",278],[15,"INC",278],[15,"DEC",278],[15,"CMP",278],[15,"MemoryOutOfBounds",188],[15,"MemoryNotAligned",188],[15,"InvalidOpcode",188],[15,"InvalidRegister",188],[8,"Result",161]],"b":[[179,"impl-Display-for-VmError"],[180,"impl-Debug-for-VmError"],[259,"impl-Debug-for-Instruction%3CD,+A%3E"],[260,"impl-Display-for-Instruction%3CD,+T%3E"]]}],\
["log",{"doc":"A lightweight logging facade.","t":"PPPPPPGGKFFPFFFSFPPPPNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNQNNMNNNNNNNQNNNNMNNNNNNNNNNNNNNNNNNNNNNNNNNQNNNNNNNNNNNNNNNNMQQHNNHNNNNNNNNNNNNNNHHHHNNNNNNQNNNNNNNNNNNNNNNNNNNNNNNNQ","n":["Debug","Debug","Error","Error","Info","Info","Level","LevelFilter","Log","Metadata","MetadataBuilder","Off","ParseLevelError","Record","RecordBuilder","STATIC_MAX_LEVEL","SetLoggerError","Trace","Trace","Warn","Warn","args","args","as_str","as_str","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","build","build","builder","builder","clone","clone","clone","clone","cmp","cmp","cmp","cmp","debug","default","default","enabled","eq","eq","eq","eq","eq","eq","eq","error","file","file","file_static","file_static","flush","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","from","from","from","from","from","from","from","from","from_str","from_str","hash","hash","hash","hash","info","into","into","into","into","into","into","into","into","iter","iter","level","level","level","level","line","line","log","log","log_enabled","logger","max","max","max_level","metadata","metadata","module_path","module_path","module_path_static","module_path_static","new","new","partial_cmp","partial_cmp","partial_cmp","partial_cmp","partial_cmp","partial_cmp","set_logger","set_logger_racy","set_max_level","set_max_level_racy","target","target","target","target","to_level","to_level_filter","trace","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","warn"],"q":[[0,"log"],[170,"core::fmt"],[171,"core::cmp"],[172,"core::option"],[173,"core::fmt"],[174,"core::hash"],[175,"core::iter::traits::iterator"],[176,"core::any"]],"d":["The “debug” level.","Corresponds to the <code>Debug</code> log level.","The “error” level.","Corresponds to the <code>Error</code> log level.","The “info” level.","Corresponds to the <code>Info</code> log level.","An enum representing the available verbosity levels of the …","An enum representing the available verbosity level filters …","A trait encapsulating the operations required of a logger.","Metadata about a log message.","Builder for <code>Metadata</code>.","A level lower than all log levels.","The type returned by <code>from_str</code> when the string doesn’t …","The “payload” of a log message.","Builder for <code>Record</code>.","The statically resolved maximum log level.","The type returned by <code>set_logger</code> if <code>set_logger</code> has already …","The “trace” level.","Corresponds to the <code>Trace</code> log level.","The “warn” level.","Corresponds to the <code>Warn</code> log level.","The message body.","Set <code>args</code>.","Returns the string representation of the <code>Level</code>.","Returns the string representation of the <code>LevelFilter</code>.","","","","","","","","","","","","","","","","","Invoke the builder and return a <code>Record</code>","Returns a <code>Metadata</code> object.","Returns a new builder.","Returns a new builder.","","","","","","","","","Logs a message at the debug level.","","","Determines if a log message with the specified metadata …","","","","","","","","Logs a message at the error level.","The source file containing the message.","Set <code>file</code>","The source file containing the message, if it is a <code>&#39;static</code> …","Set <code>file</code> to a <code>&#39;static</code> string.","Flushes any buffered records.","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","","","","","","","Logs a message at the info level.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Iterate through all supported logging levels.","Iterate through all supported filtering levels.","The verbosity level of the message.","Set <code>Metadata::level</code>.","The verbosity level of the message.","Setter for <code>level</code>.","The line containing the message.","Set <code>line</code>","Logs the <code>Record</code>.","The standard logging macro.","Determines if a message logged at the specified level in …","Returns a reference to the logger.","Returns the most verbose logging level.","Returns the most verbose logging level filter.","Returns the current maximum log level.","Metadata about the log directive.","Set <code>metadata</code>. Construct a <code>Metadata</code> object with …","The module path of the message.","Set <code>module_path</code>","The module path of the message, if it is a <code>&#39;static</code> string.","Set <code>module_path</code> to a <code>&#39;static</code> string","Construct new <code>RecordBuilder</code>.","Construct a new <code>MetadataBuilder</code>.","","","","","","","Sets the global logger to a <code>&amp;&#39;static Log</code>.","A thread-unsafe version of <code>set_logger</code>.","Sets the global maximum log level.","A thread-unsafe version of <code>set_max_level</code>.","The name of the target of the directive.","Set <code>Metadata::target</code>","The name of the target of the directive.","Setter for <code>target</code>.","Converts <code>self</code> to the equivalent <code>Level</code>.","Converts the <code>Level</code> to the equivalent <code>LevelFilter</code>.","Logs a message at the trace level.","","","","","","","","","","","","","","","","","","","","","","","","","Logs a message at the warn level."],"i":[4,6,4,6,4,6,0,0,0,0,0,6,0,0,0,0,0,4,6,4,6,1,3,4,6,4,6,1,3,8,7,17,12,4,6,1,3,8,7,17,12,3,7,1,8,4,6,1,8,4,6,8,7,0,3,7,10,4,4,6,6,8,7,12,0,1,3,1,3,10,4,4,6,6,1,3,8,7,17,17,12,12,4,6,1,3,8,7,17,12,4,6,4,6,8,7,0,4,6,1,3,8,7,17,12,4,6,1,3,8,7,1,3,10,0,0,0,4,6,0,1,3,1,3,1,3,3,7,4,4,6,6,8,7,0,0,0,0,1,3,8,7,6,4,0,4,6,1,3,8,7,17,12,4,6,1,3,8,7,17,12,4,6,1,3,8,7,17,12,0],"f":"`````````````````````{bd}{{fd}f}{hj}{lj}{ce{}{}}000000000000000{fb}{nA`}{{}f}{{}n}{hh}{ll}{bb}{A`A`}{{hh}Ab}{{ll}Ab}{{A`A`}Ab}{{nn}Ab}`98{{AdA`}Af}{{hh}Af}{{hl}Af}{{lh}Af}{{ll}Af}{{A`A`}Af}{{nn}Af}{{AhAh}Af}`{b{{Aj{j}}}}{{f{Aj{j}}}f}10{AdAl}{{hAn}B`}0{{lAn}B`}0{{bAn}B`}{{fAn}B`}{{A`An}B`}{{nAn}B`}{{BbAn}B`}0{{AhAn}B`}0{cc{}}0000000{j{{Bd{hc}}}{}}{j{{Bd{lc}}}{}}{{hc}AlBf}{{lc}AlBf}{{A`c}AlBf}{{nc}AlBf}`{ce{}{}}0000000{{}{{`{{Bj{}{{Bh{h}}}}}}}}{{}{{`{{Bj{}{{Bh{l}}}}}}}}{bh}{{fh}f}{A`h}{{nh}n}{b{{Aj{Bl}}}}{{f{Aj{Bl}}}f}{{Adb}Al}``{{}Ad}{{}h}{{}l}0{bA`}{{fA`}f}{b{{Aj{j}}}}{{f{Aj{j}}}f}10{{}f}{{}n}{{hh}{{Aj{Ab}}}}{{hl}{{Aj{Ab}}}}{{lh}{{Aj{Ab}}}}{{ll}{{Aj{Ab}}}}{{A`A`}{{Aj{Ab}}}}{{nn}{{Aj{Ab}}}}{Ad{{Bd{AlBb}}}}0{lAl}0{bj}{{fj}f}{A`j}{{nj}n}{l{{Aj{h}}}}{hl}`{c{{Bd{e}}}{}{}}000000000000000{cBn{}}0000000`","c":[],"p":[[5,"Record",0],[5,"Arguments",170],[5,"RecordBuilder",0],[6,"Level",0],[1,"str"],[6,"LevelFilter",0],[5,"MetadataBuilder",0],[5,"Metadata",0],[6,"Ordering",171],[10,"Log",0],[1,"bool"],[5,"ParseLevelError",0],[6,"Option",172],[1,"unit"],[5,"Formatter",170],[8,"Result",170],[5,"SetLoggerError",0],[6,"Result",173],[10,"Hasher",174],[17,"Item"],[10,"Iterator",175],[1,"u32"],[5,"TypeId",176]],"b":[[57,"impl-PartialEq-for-Level"],[58,"impl-PartialEq%3CLevelFilter%3E-for-Level"],[59,"impl-PartialEq%3CLevel%3E-for-LevelFilter"],[60,"impl-PartialEq-for-LevelFilter"],[70,"impl-Display-for-Level"],[71,"impl-Debug-for-Level"],[72,"impl-Debug-for-LevelFilter"],[73,"impl-Display-for-LevelFilter"],[78,"impl-Debug-for-SetLoggerError"],[79,"impl-Display-for-SetLoggerError"],[80,"impl-Debug-for-ParseLevelError"],[81,"impl-Display-for-ParseLevelError"],[128,"impl-PartialOrd-for-Level"],[129,"impl-PartialOrd%3CLevelFilter%3E-for-Level"],[130,"impl-PartialOrd%3CLevel%3E-for-LevelFilter"],[131,"impl-PartialOrd-for-LevelFilter"]]}]\
]'));
if (typeof exports !== 'undefined') exports.searchIndex = searchIndex;
else if (window.initSearch) window.initSearch(searchIndex);
